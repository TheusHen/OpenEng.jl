var documenterSearchIndex = {"docs":
[{"location":"optimization/#Optimization","page":"Optimization","title":"Optimization","text":"","category":"section"},{"location":"optimization/","page":"Optimization","title":"Optimization","text":"The OpenEng.Optimization module provides interfaces for linear programming, nonlinear programming, and constrained optimization.","category":"page"},{"location":"optimization/#Overview","page":"Optimization","title":"Overview","text":"","category":"section"},{"location":"optimization/","page":"Optimization","title":"Optimization","text":"This module uses JuMP.jl with GLPK and Ipopt solvers for optimization problems.","category":"page"},{"location":"optimization/#Linear-Programming","page":"Optimization","title":"Linear Programming","text":"","category":"section"},{"location":"optimization/","page":"Optimization","title":"Optimization","text":"using OpenEng.Optimization\n\n# Create LP model\nmodel = create_lp_model()\n\n# Define variables\n@variable(model, x >= 0)\n@variable(model, y >= 0)\n\n# Add constraints\n@constraint(model, x + y <= 10)\n\n# Set objective\n@objective(model, Max, 3x + 5y)\n\n# Solve\noptimize!(model)\n\n# Get solution\nprintln(\"x = \", value(x))\nprintln(\"y = \", value(y))\nprintln(\"Objective = \", objective_value(model))","category":"page"},{"location":"optimization/#Nonlinear-Programming","page":"Optimization","title":"Nonlinear Programming","text":"","category":"section"},{"location":"optimization/","page":"Optimization","title":"Optimization","text":"# Create NLP model\nmodel = create_nlp_model()\n\n# Define variables\n@variable(model, x)\n@variable(model, y)\n\n# Add nonlinear constraint\n@constraint(model, x^2 + y^2 <= 1)\n\n# Set nonlinear objective\n@objective(model, Min, (x - 2)^2 + (y - 3)^2)\n\n# Solve\noptimize!(model)","category":"page"},{"location":"optimization/#Convenience-Functions","page":"Optimization","title":"Convenience Functions","text":"","category":"section"},{"location":"optimization/#solve_lp","page":"Optimization","title":"solve_lp","text":"","category":"section"},{"location":"optimization/","page":"Optimization","title":"Optimization","text":"c = [-3.0, -5.0]\nA = [1.0 1.0]\nb = [10.0]\nlb = [0.0, 0.0]\nub = [Inf, Inf]\n\nx = solve_lp(c, A, b, lb, ub)","category":"page"},{"location":"optimization/#solve_nlp","page":"Optimization","title":"solve_nlp","text":"","category":"section"},{"location":"optimization/","page":"Optimization","title":"Optimization","text":"f(x) = (x[1] - 1)^2 + (x[2] - 2)^2\nx0 = [0.0, 0.0]\nx_opt = solve_nlp(f, x0)","category":"page"},{"location":"optimization/#Main-Functions","page":"Optimization","title":"Main Functions","text":"","category":"section"},{"location":"optimization/","page":"Optimization","title":"Optimization","text":"create_model - Create optimization model\ncreate_lp_model - Linear programming model\ncreate_nlp_model - Nonlinear programming model\nsolve_lp - Solve LP in standard form\nsolve_nlp - Solve NLP from function\nget_solution - Extract solution as Dict\nget_objective - Get objective value","category":"page"},{"location":"optimization/#Examples","page":"Optimization","title":"Examples","text":"","category":"section"},{"location":"optimization/","page":"Optimization","title":"Optimization","text":"See examples/optimization_examples.jl for comprehensive examples including:","category":"page"},{"location":"optimization/","page":"Optimization","title":"Optimization","text":"Production planning\nDiet optimization\nTransportation problems\nPortfolio optimization\nParameter estimation","category":"page"},{"location":"viz/#Visualization","page":"Visualization","title":"Visualization","text":"","category":"section"},{"location":"viz/","page":"Visualization","title":"Visualization","text":"The OpenEng.Viz module provides convenient plotting functions for scientific visualization.","category":"page"},{"location":"viz/#Overview","page":"Visualization","title":"Overview","text":"","category":"section"},{"location":"viz/","page":"Visualization","title":"Visualization","text":"This module wraps Plots.jl with sensible defaults for engineering applications.","category":"page"},{"location":"viz/#Basic-Plotting","page":"Visualization","title":"Basic Plotting","text":"","category":"section"},{"location":"viz/","page":"Visualization","title":"Visualization","text":"using OpenEng.Viz\n\n# Plot a signal\nt = 0:0.01:10\ny = sin.(t)\nplot_signal(t, y, title=\"Sine Wave\")","category":"page"},{"location":"viz/#Multiple-Signals","page":"Visualization","title":"Multiple Signals","text":"","category":"section"},{"location":"viz/","page":"Visualization","title":"Visualization","text":"t = 0:0.01:10\ny1 = sin.(t)\ny2 = cos.(t)\nplot_signals(t, [y1 y2], labels=[\"sin\" \"cos\"])","category":"page"},{"location":"viz/#Frequency-Spectrum","page":"Visualization","title":"Frequency Spectrum","text":"","category":"section"},{"location":"viz/","page":"Visualization","title":"Visualization","text":"using OpenEng.Signal\nx = sin.(2π * 5 .* (0:0.001:1))\nX = fft(x)\nfreqs = fftfreq(length(x), 1000)\nplot_spectrum(freqs[1:end÷2], abs.(X[1:end÷2]))","category":"page"},{"location":"viz/#3D-Surface-Plots","page":"Visualization","title":"3D Surface Plots","text":"","category":"section"},{"location":"viz/","page":"Visualization","title":"Visualization","text":"x = -3:0.1:3\ny = -3:0.1:3\nz = [sin(sqrt(xi^2 + yi^2)) for xi in x, yi in y]\nplot_surface(x, y, z)","category":"page"},{"location":"viz/#Heatmaps","page":"Visualization","title":"Heatmaps","text":"","category":"section"},{"location":"viz/","page":"Visualization","title":"Visualization","text":"z = rand(20, 20)\nplot_heatmap(z, title=\"Random Data\")","category":"page"},{"location":"viz/#Spectrograms","page":"Visualization","title":"Spectrograms","text":"","category":"section"},{"location":"viz/","page":"Visualization","title":"Visualization","text":"using OpenEng.Signal\nx = randn(10000)\nS, f, t = compute_spectrogram(x, 256, 128, fs=1000)\nplot_spectrogram(S, f, t)","category":"page"},{"location":"viz/#System-Responses","page":"Visualization","title":"System Responses","text":"","category":"section"},{"location":"viz/","page":"Visualization","title":"Visualization","text":"using OpenEng.Simulation\nsys = tf([1.0], [1.0, 1.0])\nt, y = step_response(sys, 5.0)\nplot_response(t, y, response_type=\"Step\")","category":"page"},{"location":"viz/#Saving-Plots","page":"Visualization","title":"Saving Plots","text":"","category":"section"},{"location":"viz/","page":"Visualization","title":"Visualization","text":"p = plot_signal(t, y)\nsave_plot(p, \"output.png\", size=(800, 600), dpi=300)","category":"page"},{"location":"viz/#Main-Functions","page":"Visualization","title":"Main Functions","text":"","category":"section"},{"location":"viz/","page":"Visualization","title":"Visualization","text":"plot_signal - Plot time-domain signal\nplot_signals - Plot multiple signals\nplot_spectrum - Plot frequency spectrum\nplot_surface - 3D surface plot\nplot_heatmap - 2D heatmap\nplot_spectrogram - Time-frequency plot\nplot_response - System response plot\nsave_plot - Save plot to file\nset_default_backend - Set plotting backend","category":"page"},{"location":"viz/#Backends","page":"Visualization","title":"Backends","text":"","category":"section"},{"location":"viz/","page":"Visualization","title":"Visualization","text":"set_default_backend(:gr)      # Default\nset_default_backend(:pyplot)  # Matplotlib\nset_default_backend(:plotly)  # Interactive","category":"page"},{"location":"utils/#Utilities","page":"Utilities","title":"Utilities","text":"","category":"section"},{"location":"utils/","page":"Utilities","title":"Utilities","text":"The OpenEng.Utils module provides utility functions, file I/O, unit conversions, and physical constants.","category":"page"},{"location":"utils/#File-I/O","page":"Utilities","title":"File I/O","text":"","category":"section"},{"location":"utils/#CSV-Files","page":"Utilities","title":"CSV Files","text":"","category":"section"},{"location":"utils/","page":"Utilities","title":"Utilities","text":"using OpenEng.Utils\n\n# Write CSV\ndf = DataFrame(x=1:10, y=rand(10))\nwrite_csv(\"data.csv\", df)\n\n# Read CSV\ndf = read_csv(\"data.csv\")","category":"page"},{"location":"utils/#MATLAB-Files","page":"Utilities","title":"MATLAB Files","text":"","category":"section"},{"location":"utils/","page":"Utilities","title":"Utilities","text":"# Write .mat file\ndata = Dict(\"A\" => rand(10, 10), \"b\" => rand(10))\nwrite_mat(\"data.mat\", data)\n\n# Read .mat file\ndata = read_mat(\"data.mat\")\nA = data[\"A\"]","category":"page"},{"location":"utils/#HDF5-Files","page":"Utilities","title":"HDF5 Files","text":"","category":"section"},{"location":"utils/","page":"Utilities","title":"Utilities","text":"# Write HDF5\ndata = rand(100, 100)\nwrite_hdf5(\"data.h5\", \"dataset1\", data)\n\n# Read HDF5\ndata = read_hdf5(\"data.h5\", \"dataset1\")","category":"page"},{"location":"utils/#Unit-Conversion","page":"Utilities","title":"Unit Conversion","text":"","category":"section"},{"location":"utils/","page":"Utilities","title":"Utilities","text":"# Length conversions\nmeters = convert_units(5.0, :km, :m)  # 5000.0\nkm = convert_units(1000.0, :m, :km)   # 1.0\n\n# Time conversions\nms = convert_units(1.0, :s, :ms)      # 1000.0\n\n# Frequency conversions\nHz = convert_units(1.0, :kHz, :Hz)    # 1000.0","category":"page"},{"location":"utils/#Supported-Units","page":"Utilities","title":"Supported Units","text":"","category":"section"},{"location":"utils/","page":"Utilities","title":"Utilities","text":"Length: :m, :km, :cm, :mm, :ft, :inch","category":"page"},{"location":"utils/","page":"Utilities","title":"Utilities","text":"Time: :s, :ms, :μs, :ns","category":"page"},{"location":"utils/","page":"Utilities","title":"Utilities","text":"Frequency: :Hz, :kHz, :MHz, :GHz","category":"page"},{"location":"utils/","page":"Utilities","title":"Utilities","text":"Mass: :g, :kg, :mg","category":"page"},{"location":"utils/","page":"Utilities","title":"Utilities","text":"Others: :N, :J, :W, :A, :V, :Ω, :°C, :K, :rad, :°","category":"page"},{"location":"utils/#Physical-Constants","page":"Utilities","title":"Physical Constants","text":"","category":"section"},{"location":"utils/","page":"Utilities","title":"Utilities","text":"using OpenEng.Utils.PhysicalConstants\n\nc = SPEED_OF_LIGHT      # 299792458.0 m/s\ng = GRAVITY             # 9.80665 m/s²\nh = PLANCK              # 6.62607015e-34 J⋅s\nk = BOLTZMANN           # 1.380649e-23 J/K\nNA = AVOGADRO           # 6.02214076e23 mol⁻¹\nR = GAS_CONSTANT        # 8.314462618 J/(mol⋅K)\ne = ELEMENTARY_CHARGE   # 1.602176634e-19 C\nme = ELECTRON_MASS      # 9.1093837015e-31 kg\nmp = PROTON_MASS        # 1.67262192369e-27 kg","category":"page"},{"location":"utils/#Performance-Timing","page":"Utilities","title":"Performance Timing","text":"","category":"section"},{"location":"utils/#Timer-Object","page":"Utilities","title":"Timer Object","text":"","category":"section"},{"location":"utils/","page":"Utilities","title":"Utilities","text":"t = Utils.Timer()\n# ... do work ...\nelapsed_time = elapsed(t)\nprintln(\"Elapsed: \", elapsed_time, \" seconds\")\n\n# Reset timer\nreset!(t)","category":"page"},{"location":"utils/#Timed-Sections","page":"Utilities","title":"Timed Sections","text":"","category":"section"},{"location":"utils/","page":"Utilities","title":"Utilities","text":"result = @timed_section \"Matrix multiplication\" begin\n    C = A * B\nend","category":"page"},{"location":"utils/#DataFrame-Operations","page":"Utilities","title":"DataFrame Operations","text":"","category":"section"},{"location":"utils/","page":"Utilities","title":"Utilities","text":"using OpenEng.Utils\n\n# Create DataFrame\ndf = DataFrame(a=1:5, b=rand(5))\n\n# Access columns\nx = df.a\ny = df.b","category":"page"},{"location":"utils/#Main-Functions","page":"Utilities","title":"Main Functions","text":"","category":"section"},{"location":"utils/","page":"Utilities","title":"Utilities","text":"File I/O:","category":"page"},{"location":"utils/","page":"Utilities","title":"Utilities","text":"read_csv, write_csv - CSV files\nread_mat, write_mat - MATLAB files  \nread_hdf5, write_hdf5 - HDF5 files","category":"page"},{"location":"utils/","page":"Utilities","title":"Utilities","text":"Unit Conversion:","category":"page"},{"location":"utils/","page":"Utilities","title":"Utilities","text":"convert_units - Convert between units\nparse_unit - Parse unit symbol","category":"page"},{"location":"utils/","page":"Utilities","title":"Utilities","text":"Physical Constants:","category":"page"},{"location":"utils/","page":"Utilities","title":"Utilities","text":"PhysicalConstants module with all constants","category":"page"},{"location":"utils/","page":"Utilities","title":"Utilities","text":"Timing:","category":"page"},{"location":"utils/","page":"Utilities","title":"Utilities","text":"Timer - Timer object\nelapsed - Get elapsed time\nreset! - Reset timer\n@timed_section - Time code block","category":"page"},{"location":"utils/#Examples","page":"Utilities","title":"Examples","text":"","category":"section"},{"location":"utils/","page":"Utilities","title":"Utilities","text":"Complete workflows for data processing, file conversion, and performance measurement can be found in the examples directory.","category":"page"},{"location":"signal/#Signal-Processing","page":"Signal Processing","title":"Signal Processing","text":"","category":"section"},{"location":"signal/","page":"Signal Processing","title":"Signal Processing","text":"The OpenEng.Signal module provides digital signal processing tools including FFT, filtering, and spectral analysis.","category":"page"},{"location":"signal/#Overview","page":"Signal Processing","title":"Overview","text":"","category":"section"},{"location":"signal/","page":"Signal Processing","title":"Signal Processing","text":"This module wraps FFTW.jl and DSP.jl to provide MATLAB-style signal processing functions.","category":"page"},{"location":"signal/#FFT-Analysis","page":"Signal Processing","title":"FFT Analysis","text":"","category":"section"},{"location":"signal/","page":"Signal Processing","title":"Signal Processing","text":"using OpenEng.Signal\n\n# Generate signal\nfs = 1000.0  # Sampling frequency\nt = 0:1/fs:1-1/fs\nx = sin.(2π * 50 .* t)  # 50 Hz sine wave\n\n# Compute FFT\nX = fft(x)\nfreqs = fftfreq(length(x), 1/fs)","category":"page"},{"location":"signal/#Filter-Design","page":"Signal Processing","title":"Filter Design","text":"","category":"section"},{"location":"signal/#Butterworth-Filters","page":"Signal Processing","title":"Butterworth Filters","text":"","category":"section"},{"location":"signal/","page":"Signal Processing","title":"Signal Processing","text":"# Design 4th order lowpass filter\nb, a = butter(4, 0.2)  # Cutoff at 0.2*Nyquist\n\n# Apply filter\ny = filter_signal(b, a, x)","category":"page"},{"location":"signal/#Chebyshev-Filters","page":"Signal Processing","title":"Chebyshev Filters","text":"","category":"section"},{"location":"signal/","page":"Signal Processing","title":"Signal Processing","text":"# Type I: passband ripple\nb, a = cheby1(4, 0.5, 0.2)\n\n# Type II: stopband attenuation\nb, a = cheby2(4, 40, 0.2)","category":"page"},{"location":"signal/#Elliptic-Filters","page":"Signal Processing","title":"Elliptic Filters","text":"","category":"section"},{"location":"signal/","page":"Signal Processing","title":"Signal Processing","text":"b, a = ellip(4, 0.5, 40, 0.2)","category":"page"},{"location":"signal/#Spectral-Analysis","page":"Signal Processing","title":"Spectral Analysis","text":"","category":"section"},{"location":"signal/#Power-Spectral-Density","page":"Signal Processing","title":"Power Spectral Density","text":"","category":"section"},{"location":"signal/","page":"Signal Processing","title":"Signal Processing","text":"# Welch's method\nP, f = power_spectrum(x, method=:welch, fs=1000)\n\n# Periodogram\nP, f = power_spectrum(x, method=:periodogram, fs=1000)","category":"page"},{"location":"signal/#Spectrogram","page":"Signal Processing","title":"Spectrogram","text":"","category":"section"},{"location":"signal/","page":"Signal Processing","title":"Signal Processing","text":"S, f, t = compute_spectrogram(x, 256, 128, fs=1000)","category":"page"},{"location":"signal/#Main-Functions","page":"Signal Processing","title":"Main Functions","text":"","category":"section"},{"location":"signal/","page":"Signal Processing","title":"Signal Processing","text":"fft, ifft - Fast Fourier Transform\nrfft, irfft - Real FFT\nfftfreq, rfftfreq - Frequency bins\nbutter, cheby1, cheby2, ellip - Filter design\nfilter_signal - Apply filter\npower_spectrum - PSD estimation\ncompute_spectrogram - Time-frequency analysis","category":"page"},{"location":"signal/#Examples","page":"Signal Processing","title":"Examples","text":"","category":"section"},{"location":"signal/","page":"Signal Processing","title":"Signal Processing","text":"See examples/signal_processing_examples.jl for comprehensive examples.","category":"page"},{"location":"api/#API-Reference","page":"API Reference","title":"API Reference","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Complete API documentation for all OpenEng.jl modules.","category":"page"},{"location":"api/#OpenEng","page":"API Reference","title":"OpenEng","text":"","category":"section"},{"location":"api/#OpenEng","page":"API Reference","title":"OpenEng","text":"OpenEng.jl\n\nOpen-source scientific and engineering toolbox for Julia.\n\nOpenEng.jl provides a modular framework for scientific computing, numerical simulation, signal processing, optimization, and visualization - a modern, high-performance alternative to MATLAB and its toolboxes.\n\nModules\n\nOpenEng.LA (LinearAlgebra): Advanced linear algebra operations\nOpenEng.Simulation: Dynamic system modeling and ODE/PDE solvers\nOpenEng.Signal: Signal and image processing\nOpenEng.Optimization: Optimization problem solving\nOpenEng.Viz: Visualization and plotting\nOpenEng.GPU: GPU-accelerated computing with CPU fallback\nOpenEng.Utils: Utilities, I/O, and unit conversions\n\nQuick Start\n\nusing OpenEng\n\n# Linear algebra\nA = [3.0 2.0; 1.0 4.0]\nλ, V = OpenEng.LA.eig(A)\n\n# Signal processing\nx = sin.(2π * 5 .* (0:0.001:1))\nX = OpenEng.Signal.fft(x)\n\nSee the documentation and examples for more details.\n\n\n\n\n\n","category":"module"},{"location":"api/#OpenEng.version","page":"API Reference","title":"OpenEng.version","text":"version()\n\nReturn the version of OpenEng.jl.\n\n\n\n\n\n","category":"function"},{"location":"api/#OpenEng.info","page":"API Reference","title":"OpenEng.info","text":"info()\n\nDisplay information about OpenEng.jl modules and capabilities.\n\n\n\n\n\n","category":"function"},{"location":"api/#Linear-Algebra-(LA)","page":"API Reference","title":"Linear Algebra (LA)","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Modules = [OpenEng.LA]","category":"page"},{"location":"api/#OpenEng.LA","page":"API Reference","title":"OpenEng.LA","text":"OpenEng.LA (LinearAlgebra)\n\nAdvanced linear algebra operations and matrix computations.\n\nThis module provides convenient wrappers and extensions to Julia's LinearAlgebra and SparseArrays packages, with MATLAB-compatible naming where appropriate.\n\nMain Functions\n\neig: Compute eigenvalues and eigenvectors\nsvd: Singular value decomposition\nqr: QR decomposition\nlu: LU decomposition\nchol: Cholesky decomposition\nMatrix operations: inv, det, rank, norm, cond\nSparse matrices: sparse, issparse, nnz\n\nExamples\n\nusing OpenEng.LA\n\nA = [3.0 2.0; 1.0 4.0]\nλ, V = eig(A)  # Eigenvalues and eigenvectors\n\nU, S, Vt = svd(A)  # SVD decomposition\n\n# Sparse matrices\nS = sparse([1, 2, 3], [1, 2, 3], [1.0, 2.0, 3.0])\n\n\n\n\n\n","category":"module"},{"location":"api/#OpenEng.LA.chol!-Tuple{AbstractMatrix}","page":"API Reference","title":"OpenEng.LA.chol!","text":"chol!(A) -> U\n\nIn-place version of chol. Modifies the input matrix.\n\n\n\n\n\n","category":"method"},{"location":"api/#OpenEng.LA.chol-Tuple{AbstractMatrix}","page":"API Reference","title":"OpenEng.LA.chol","text":"chol(A) -> U\n\nCompute the Cholesky decomposition of a positive definite matrix A.\n\nReturns the upper triangular matrix U such that A = U'U.\n\nArguments\n\nA: A positive definite matrix\n\nReturns\n\nU: Upper triangular Cholesky factor\n\nExamples\n\nA = [4.0 2.0; 2.0 3.0]\nU = chol(A)\n@assert A ≈ U'U\n\n\n\n\n\n","category":"method"},{"location":"api/#OpenEng.LA.eig!-Tuple{AbstractMatrix}","page":"API Reference","title":"OpenEng.LA.eig!","text":"eig!(A) -> (λ, V)\n\nIn-place version of eig. Modifies the input matrix.\n\n\n\n\n\n","category":"method"},{"location":"api/#OpenEng.LA.eig-Tuple{AbstractMatrix}","page":"API Reference","title":"OpenEng.LA.eig","text":"eig(A) -> (λ, V)\n\nCompute eigenvalues and eigenvectors of matrix A.\n\nReturns a tuple (λ, V) where λ is a vector of eigenvalues and V is a matrix whose columns are the corresponding eigenvectors.\n\nArguments\n\nA: A square matrix\n\nReturns\n\nλ: Vector of eigenvalues\nV: Matrix of eigenvectors (columns)\n\nExamples\n\nA = [3.0 2.0; 1.0 4.0]\nλ, V = eig(A)\n\n\n\n\n\n","category":"method"},{"location":"api/#OpenEng.LA.frobenius_norm-Tuple{AbstractMatrix}","page":"API Reference","title":"OpenEng.LA.frobenius_norm","text":"frobenius_norm(A) -> ||A||_F\n\nCompute the Frobenius norm of matrix A.\n\nArguments\n\nA: A matrix\n\nReturns\n\nFrobenius norm (square root of sum of squared elements)\n\nExamples\n\nA = [1.0 2.0; 3.0 4.0]\nnrm = frobenius_norm(A)\n\n\n\n\n\n","category":"method"},{"location":"api/#OpenEng.LA.matrix_exp-Tuple{AbstractMatrix}","page":"API Reference","title":"OpenEng.LA.matrix_exp","text":"matrix_exp(A) -> exp(A)\n\nCompute the matrix exponential of A using eigenvalue decomposition.\n\nArguments\n\nA: A square matrix\n\nReturns\n\nexp(A): Matrix exponential\n\nExamples\n\nA = [0.0 1.0; -1.0 0.0]\nexpA = matrix_exp(A)\n\n\n\n\n\n","category":"method"},{"location":"api/#OpenEng.LA.matrix_power-Tuple{AbstractMatrix, Integer}","page":"API Reference","title":"OpenEng.LA.matrix_power","text":"matrix_power(A, n) -> A^n\n\nCompute the n-th power of a matrix A.\n\nArguments\n\nA: A square matrix\nn: Integer exponent\n\nReturns\n\nA^n: Matrix power\n\nExamples\n\nA = [1.0 1.0; 0.0 1.0]\nA2 = matrix_power(A, 2)\n\n\n\n\n\n","category":"method"},{"location":"api/#OpenEng.LA.solve!-Tuple{AbstractMatrix, AbstractVecOrMat}","page":"API Reference","title":"OpenEng.LA.solve!","text":"solve!(A, b) -> x\n\nIn-place version of solve. May modify input arrays.\n\n\n\n\n\n","category":"method"},{"location":"api/#OpenEng.LA.solve-Tuple{AbstractMatrix, AbstractVecOrMat}","page":"API Reference","title":"OpenEng.LA.solve","text":"solve(A, b) -> x\n\nSolve the linear system Ax = b.\n\nArguments\n\nA: Coefficient matrix\nb: Right-hand side vector or matrix\n\nReturns\n\nx: Solution vector or matrix\n\nExamples\n\nA = [3.0 2.0; 1.0 4.0]\nb = [1.0, 2.0]\nx = solve(A, b)\n@assert A * x ≈ b\n\n\n\n\n\n","category":"method"},{"location":"api/#OpenEng.LA.spectral_norm-Tuple{AbstractMatrix}","page":"API Reference","title":"OpenEng.LA.spectral_norm","text":"spectral_norm(A) -> ||A||_2\n\nCompute the spectral norm (2-norm) of matrix A.\n\nArguments\n\nA: A matrix\n\nReturns\n\nSpectral norm (largest singular value)\n\nExamples\n\nA = [1.0 2.0; 3.0 4.0]\nnrm = spectral_norm(A)\n\n\n\n\n\n","category":"method"},{"location":"api/#OpenEng.LA.svd-Tuple{AbstractMatrix}","page":"API Reference","title":"OpenEng.LA.svd","text":"svd(A) -> (U, S, Vt)\n\nCompute the singular value decomposition of matrix A.\n\nReturns MATLAB-style tuple (U, S, Vt) where A ≈ U * Diagonal(S) * Vt.\n\nArguments\n\nA: Matrix to decompose\n\nReturns\n\nU: Left singular vectors (m × k matrix for thin SVD)\nS: Singular values (vector of length k)\nVt: Right singular vectors transposed (k × n matrix)\n\nExamples\n\nA = rand(5, 3)\nU, S, Vt = svd(A)\n@assert A ≈ U * Diagonal(S) * Vt\n\n\n\n\n\n","category":"method"},{"location":"api/#Simulation","page":"API Reference","title":"Simulation","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Modules = [OpenEng.Simulation]","category":"page"},{"location":"api/#OpenEng.Simulation","page":"API Reference","title":"OpenEng.Simulation","text":"OpenEng.Simulation\n\nDynamic system modeling and numerical simulation.\n\nThis module provides tools for simulating ordinary differential equations (ODEs), partial differential equations (PDEs), and control systems.\n\nMain Functions\n\nsolve_ode: Solve ordinary differential equations\ntf: Create transfer function\nstep_response: Compute step response of a system\nimpulse_response: Compute impulse response\nfrequency_response: Compute frequency response\n\nExamples\n\nusing OpenEng.Simulation\n\n# Solve an ODE\nfunction pendulum!(du, u, p, t)\n    du[1] = u[2]\n    du[2] = -sin(u[1])\nend\nu0 = [π/4, 0.0]\ntspan = (0.0, 10.0)\nsol = solve_ode(pendulum!, u0, tspan)\n\n# Transfer function\nsys = tf([1.0], [1.0, 2.0, 1.0])\nt, y = step_response(sys, 5.0)\n\n\n\n\n\n","category":"module"},{"location":"api/#OpenEng.Simulation.create_ss-NTuple{4, Any}","page":"API Reference","title":"OpenEng.Simulation.create_ss","text":"create_ss(A, B, C, D) -> sys\n\nCreate a state-space system from matrices A, B, C, D.\n\nArguments\n\nA: State matrix\nB: Input matrix\nC: Output matrix\nD: Feedthrough matrix\n\nReturns\n\nState-space system\n\nExamples\n\nA = [-1.0 0.0; 0.0 -2.0]\nB = [1.0; 1.0]\nC = [1.0 1.0]\nD = [0.0]\nsys = create_ss(A, B, C, D)\n\n\n\n\n\n","category":"method"},{"location":"api/#OpenEng.Simulation.create_tf-Tuple{Any, Any}","page":"API Reference","title":"OpenEng.Simulation.create_tf","text":"create_tf(num, den) -> sys\n\nCreate a transfer function from numerator and denominator coefficients.\n\nArguments\n\nnum: Numerator polynomial coefficients (highest degree first)\nden: Denominator polynomial coefficients (highest degree first)\n\nReturns\n\nTransfer function system\n\nExamples\n\nsys = create_tf([1.0], [1.0, 2.0, 1.0])  # 1/(s^2 + 2s + 1)\n\n\n\n\n\n","category":"method"},{"location":"api/#OpenEng.Simulation.frequency_response-Tuple{Any, Any}","page":"API Reference","title":"OpenEng.Simulation.frequency_response","text":"frequency_response(sys, ω) -> (mag, phase)\n\nCompute the frequency response of a linear system.\n\nArguments\n\nsys: Transfer function or state-space system\nω: Vector of frequencies (rad/s)\n\nReturns\n\nmag: Magnitude response\nphase: Phase response (radians)\n\nExamples\n\nsys = tf([1.0], [1.0, 2.0, 1.0])\nω = 10 .^ range(-2, 2, length=100)\nmag, phase = frequency_response(sys, ω)\n\n\n\n\n\n","category":"method"},{"location":"api/#OpenEng.Simulation.impulse_response-Tuple{Any, Any}","page":"API Reference","title":"OpenEng.Simulation.impulse_response","text":"impulse_response(sys, tfinal; dt=0.01) -> (t, y)\n\nCompute the impulse response of a linear system.\n\nArguments\n\nsys: Transfer function or state-space system\ntfinal: Final time for simulation\ndt: Time step (optional)\n\nReturns\n\nt: Time vector\ny: Response vector\n\nExamples\n\nsys = tf([1.0], [1.0, 2.0, 1.0])\nt, y = impulse_response(sys, 5.0)\n\n\n\n\n\n","category":"method"},{"location":"api/#OpenEng.Simulation.simulate_system-Tuple{Any, Any, Any}","page":"API Reference","title":"OpenEng.Simulation.simulate_system","text":"simulate_system(sys, u, t) -> (y, t, x)\n\nSimulate a linear system with input signal u.\n\nArguments\n\nsys: Transfer function or state-space system\nu: Input signal (function or vector)\nt: Time vector\n\nReturns\n\ny: Output signal\nt: Time vector\nx: State trajectory\n\nExamples\n\nsys = tf([1.0], [1.0, 1.0])\nt = 0:0.01:5\nu = sin.(t)\ny, t_out, x = simulate_system(sys, u, t)\n\n\n\n\n\n","category":"method"},{"location":"api/#OpenEng.Simulation.solve_ode-Tuple{Any, Any, Any}","page":"API Reference","title":"OpenEng.Simulation.solve_ode","text":"solve_ode(f!, u0, tspan; kwargs...) -> sol\n\nSolve an ordinary differential equation.\n\nArguments\n\nf!: In-place function defining the ODE: f!(du, u, p, t)\nu0: Initial condition\ntspan: Time span tuple (t0, tf)\nkwargs...: Additional arguments passed to the ODE solver\n\nReturns\n\nsol: Solution object with fields t (time) and u (state)\n\nExamples\n\nfunction exponential_decay!(du, u, p, t)\n    du[1] = -0.5 * u[1]\nend\nu0 = [1.0]\ntspan = (0.0, 10.0)\nsol = solve_ode(exponential_decay!, u0, tspan)\n\n\n\n\n\n","category":"method"},{"location":"api/#OpenEng.Simulation.solve_ode_adaptive-Tuple{Any, Any, Any}","page":"API Reference","title":"OpenEng.Simulation.solve_ode_adaptive","text":"solve_ode_adaptive(f!, u0, tspan; kwargs...) -> sol\n\nSolve an ODE with adaptive time stepping and error control.\n\nUses high-order Runge-Kutta methods with automatic step size adjustment.\n\nArguments\n\nf!: In-place function defining the ODE\nu0: Initial condition\ntspan: Time span tuple\nkwargs...: Solver options (reltol, abstol, etc.)\n\nReturns\n\nSolution object\n\nExamples\n\nfunction stiff_system!(du, u, p, t)\n    du[1] = -1000 * u[1] + u[2]\n    du[2] = u[1] - u[2]\nend\nu0 = [1.0, 0.0]\ntspan = (0.0, 1.0)\nsol = solve_ode_adaptive(stiff_system!, u0, tspan, reltol=1e-6)\n\n\n\n\n\n","category":"method"},{"location":"api/#OpenEng.Simulation.step_response-Tuple{Any, Any}","page":"API Reference","title":"OpenEng.Simulation.step_response","text":"step_response(sys, tfinal; dt=0.01) -> (t, y)\n\nCompute the step response of a linear system.\n\nArguments\n\nsys: Transfer function or state-space system\ntfinal: Final time for simulation\ndt: Time step (optional)\n\nReturns\n\nt: Time vector\ny: Response vector\n\nExamples\n\nsys = tf([1.0], [1.0, 2.0, 1.0])\nt, y = step_response(sys, 5.0)\n\n\n\n\n\n","category":"method"},{"location":"api/#Signal-Processing","page":"API Reference","title":"Signal Processing","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Modules = [OpenEng.Signal]","category":"page"},{"location":"api/#OpenEng.Signal","page":"API Reference","title":"OpenEng.Signal","text":"OpenEng.Signal\n\nSignal and image processing tools.\n\nThis module provides functions for digital signal processing, including FFT, filtering, spectral analysis, and more.\n\nMain Functions\n\nfft, ifft: Fast Fourier Transform\nrfft, irfft: Real FFT\nfftshift, ifftshift: FFT frequency shifting\nfilter: Apply digital filter\nbutter, cheby1: Filter design\nspectrogram: Compute spectrogram\nwelch: Welch's power spectral density estimate\n\nExamples\n\nusing OpenEng.Signal\n\n# FFT example\nx = sin.(2π * 5 .* (0:0.001:1))  # 5 Hz sine\nX = fft(x)\nfreqs = fftfreq(length(x), 1/0.001)\n\n# Filter design\nb, a = butter(4, 0.5)  # 4th order Butterworth\ny = filter(b, a, x)\n\n\n\n\n\n","category":"module"},{"location":"api/#OpenEng.Signal.butter-Tuple{Integer, Any}","page":"API Reference","title":"OpenEng.Signal.butter","text":"butter(n, Wn; btype=:lowpass, analog=false) -> (b, a)\n\nDesign an nth-order Butterworth filter.\n\nArguments\n\nn: Filter order\nWn: Cutoff frequency (normalized to Nyquist if digital)\nbtype: Filter type (:lowpass, :highpass, :bandpass, :bandstop)\nanalog: If true, design analog filter\n\nReturns\n\nb: Numerator coefficients\na: Denominator coefficients\n\nExamples\n\nb, a = butter(4, 0.2)  # 4th order lowpass at 0.2*Nyquist\ny = filt(b, a, x)\n\n\n\n\n\n","category":"method"},{"location":"api/#OpenEng.Signal.cheby1-Tuple{Integer, Real, Any}","page":"API Reference","title":"OpenEng.Signal.cheby1","text":"cheby1(n, rp, Wn; btype=:lowpass) -> (b, a)\n\nDesign an nth-order Chebyshev Type I filter.\n\nArguments\n\nn: Filter order\nrp: Passband ripple (dB)\nWn: Cutoff frequency\nbtype: Filter type\n\nReturns\n\nb, a: Filter coefficients\n\nExamples\n\nb, a = cheby1(4, 0.5, 0.2)  # 0.5 dB ripple\n\n\n\n\n\n","category":"method"},{"location":"api/#OpenEng.Signal.cheby2-Tuple{Integer, Real, Any}","page":"API Reference","title":"OpenEng.Signal.cheby2","text":"cheby2(n, rs, Wn; btype=:lowpass) -> (b, a)\n\nDesign an nth-order Chebyshev Type II filter.\n\nArguments\n\nn: Filter order\nrs: Stopband attenuation (dB)\nWn: Cutoff frequency\nbtype: Filter type\n\nReturns\n\nb, a: Filter coefficients\n\n\n\n\n\n","category":"method"},{"location":"api/#OpenEng.Signal.compute_spectrogram","page":"API Reference","title":"OpenEng.Signal.compute_spectrogram","text":"compute_spectrogram(x, n=256, noverlap=128, window=nothing) -> (S, f, t)\n\nCompute the spectrogram of signal x.\n\nArguments\n\nx: Input signal\nn: FFT length\nnoverlap: Number of overlapping samples\nwindow: Window function (default: Hamming)\n\nReturns\n\nS: Spectrogram matrix (frequency × time)\nf: Frequency vector\nt: Time vector\n\nExamples\n\nx = randn(10000)\nS, f, t = compute_spectrogram(x, 256)\n\n\n\n\n\n","category":"function"},{"location":"api/#OpenEng.Signal.ellip-Tuple{Integer, Real, Real, Any}","page":"API Reference","title":"OpenEng.Signal.ellip","text":"ellip(n, rp, rs, Wn; btype=:lowpass) -> (b, a)\n\nDesign an nth-order Elliptic (Cauer) filter.\n\nArguments\n\nn: Filter order\nrp: Passband ripple (dB)\nrs: Stopband attenuation (dB)\nWn: Cutoff frequency\nbtype: Filter type\n\nReturns\n\nb, a: Filter coefficients\n\nExamples\n\nb, a = ellip(4, 0.5, 40, 0.2)\n\n\n\n\n\n","category":"method"},{"location":"api/#OpenEng.Signal.fftfreq","page":"API Reference","title":"OpenEng.Signal.fftfreq","text":"fftfreq(n, d=1.0) -> freqs\n\nCompute FFT frequency bins.\n\nArguments\n\nn: Number of samples\nd: Sample spacing (inverse of sampling rate)\n\nReturns\n\nfreqs: Frequency vector\n\nExamples\n\nn = 1000\nfs = 1000.0  # 1 kHz sampling rate\nfreqs = fftfreq(n, 1/fs)\n\n\n\n\n\n","category":"function"},{"location":"api/#OpenEng.Signal.filter_signal-Tuple{Any, Any, Any}","page":"API Reference","title":"OpenEng.Signal.filter_signal","text":"filter_signal(b, a, x) -> y\n\nApply a digital filter to signal x.\n\nArguments\n\nb: Numerator coefficients\na: Denominator coefficients\nx: Input signal\n\nReturns\n\ny: Filtered signal\n\nExamples\n\nb, a = butter(4, 0.2)\ny = filter_signal(b, a, x)\n\n\n\n\n\n","category":"method"},{"location":"api/#OpenEng.Signal.power_spectrum-Tuple{AbstractVector}","page":"API Reference","title":"OpenEng.Signal.power_spectrum","text":"power_spectrum(x; method=:welch, kwargs...) -> (P, f)\n\nCompute the power spectral density of signal x.\n\nArguments\n\nx: Input signal\nmethod: Method to use (:welch or :periodogram)\nkwargs...: Additional arguments for the method\n\nReturns\n\nP: Power spectral density\nf: Frequency vector\n\nExamples\n\nx = sin.(2π * 10 .* (0:0.001:1)) + randn(1001) * 0.1\nP, f = power_spectrum(x, fs=1000)\n\n\n\n\n\n","category":"method"},{"location":"api/#OpenEng.Signal.rfftfreq","page":"API Reference","title":"OpenEng.Signal.rfftfreq","text":"rfftfreq(n, d=1.0) -> freqs\n\nCompute RFFT frequency bins (positive frequencies only).\n\nArguments\n\nn: Number of samples\nd: Sample spacing\n\nReturns\n\nfreqs: Positive frequency vector\n\nExamples\n\nn = 1000\nfs = 1000.0\nfreqs = rfftfreq(n, 1/fs)\n\n\n\n\n\n","category":"function"},{"location":"api/#Optimization","page":"API Reference","title":"Optimization","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Modules = [OpenEng.Optimization]","category":"page"},{"location":"api/#OpenEng.Optimization","page":"API Reference","title":"OpenEng.Optimization","text":"OpenEng.Optimization\n\nOptimization problem solving and mathematical programming.\n\nThis module provides interfaces for linear programming, nonlinear programming, and constrained optimization using JuMP.jl and various solvers.\n\nMain Functions\n\ncreate_model: Create optimization model\nsolve_lp: Solve linear programming problem\nsolve_nlp: Solve nonlinear programming problem\noptimize!: Solve optimization model\n\nExamples\n\nusing OpenEng.Optimization\n\n# Linear programming\nmodel = create_model()\n@variable(model, x >= 0)\n@variable(model, y >= 0)\n@constraint(model, x + y <= 10)\n@objective(model, Max, 3x + 5y)\noptimize!(model)\n\n\n\n\n\n","category":"module"},{"location":"api/#OpenEng.Optimization.create_lp_model-Tuple{}","page":"API Reference","title":"OpenEng.Optimization.create_lp_model","text":"create_lp_model(; silent=true) -> model\n\nCreate a linear programming model using GLPK.\n\nArguments\n\nsilent: Suppress solver output\n\nReturns\n\nJuMP model configured for LP\n\nExamples\n\nmodel = create_lp_model()\n@variable(model, x >= 0)\n@variable(model, y >= 0)\n@constraint(model, x + 2y <= 10)\n@objective(model, Max, 3x + 4y)\noptimize!(model)\nprintln(\"x = \", value(x), \", y = \", value(y))\n\n\n\n\n\n","category":"method"},{"location":"api/#OpenEng.Optimization.create_model-Tuple{}","page":"API Reference","title":"OpenEng.Optimization.create_model","text":"create_model(; solver=nothing, silent=true) -> model\n\nCreate an optimization model.\n\nArguments\n\nsolver: Solver to use (:ipopt, :glpk, or nothing for auto-detect)\nsilent: Suppress solver output\n\nReturns\n\nJuMP model\n\nExamples\n\nmodel = create_model(solver=:glpk)\n@variable(model, x >= 0)\n\n\n\n\n\n","category":"method"},{"location":"api/#OpenEng.Optimization.create_nlp_model-Tuple{}","page":"API Reference","title":"OpenEng.Optimization.create_nlp_model","text":"create_nlp_model(; silent=true) -> model\n\nCreate a nonlinear programming model using Ipopt.\n\nArguments\n\nsilent: Suppress solver output\n\nReturns\n\nJuMP model configured for NLP\n\nExamples\n\nmodel = create_nlp_model()\n@variable(model, x)\n@variable(model, y)\n@NLconstraint(model, x^2 + y^2 <= 1)\n@NLobjective(model, Min, (x - 1)^2 + (y - 2)^2)\noptimize!(model)\n\n\n\n\n\n","category":"method"},{"location":"api/#OpenEng.Optimization.get_objective-Tuple{Model}","page":"API Reference","title":"OpenEng.Optimization.get_objective","text":"get_objective(model) -> Float64\n\nGet the objective value of an optimized model.\n\nArguments\n\nmodel: Optimized JuMP model\n\nReturns\n\nObjective value\n\nExamples\n\noptimize!(model)\nobj_val = get_objective(model)\n\n\n\n\n\n","category":"method"},{"location":"api/#OpenEng.Optimization.get_solution-Tuple{Model}","page":"API Reference","title":"OpenEng.Optimization.get_solution","text":"get_solution(model) -> Dict\n\nExtract solution from an optimized model.\n\nArguments\n\nmodel: Optimized JuMP model\n\nReturns\n\nDictionary with solution values\n\nExamples\n\noptimize!(model)\nsol = get_solution(model)\n\n\n\n\n\n","category":"method"},{"location":"api/#OpenEng.Optimization.solve_lp-Tuple{AbstractVector, AbstractMatrix, AbstractVector, AbstractVector, AbstractVector}","page":"API Reference","title":"OpenEng.Optimization.solve_lp","text":"solve_lp(c, A, b, lb, ub) -> x\n\nSolve a linear program in standard form:     minimize    c'x     subject to  Ax ≤ b                 lb ≤ x ≤ ub\n\nArguments\n\nc: Objective coefficients\nA: Constraint matrix\nb: Constraint bounds\nlb: Lower bounds on variables\nub: Upper bounds on variables\n\nReturns\n\nx: Optimal solution\n\nExamples\n\nc = [-3.0, -5.0]\nA = [1.0 1.0]\nb = [10.0]\nlb = [0.0, 0.0]\nub = [Inf, Inf]\nx = solve_lp(c, A, b, lb, ub)\n\n\n\n\n\n","category":"method"},{"location":"api/#OpenEng.Optimization.solve_nlp-Tuple{Function, AbstractVector}","page":"API Reference","title":"OpenEng.Optimization.solve_nlp","text":"solve_nlp(f, x0; constraints=nothing, bounds=nothing) -> x\n\nSolve a nonlinear programming problem.\n\nArguments\n\nf: Objective function (must accept vector input: f(x))\nx0: Initial guess\nconstraints: Optional constraint functions\nbounds: Optional variable bounds\n\nReturns\n\nx: Optimal solution\n\nExamples\n\nf(x) = (x[1] - 1)^2 + (x[2] - 2)^2\nx0 = [0.0, 0.0]\nx_opt = solve_nlp(f, x0)\n\n\n\n\n\n","category":"method"},{"location":"api/#Visualization","page":"API Reference","title":"Visualization","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Modules = [OpenEng.Viz]","category":"page"},{"location":"api/#OpenEng.Viz","page":"API Reference","title":"OpenEng.Viz","text":"OpenEng.Viz\n\nVisualization and plotting tools.\n\nThis module provides convenient wrappers for creating scientific plots using Plots.jl with sensible defaults for engineering applications.\n\nMain Functions\n\nplot_signal: Plot time-domain signal\nplot_spectrum: Plot frequency spectrum\nplot_surface: Plot 3D surface\nplot_heatmap: Plot 2D heatmap\nsave_plot: Save plot to file\n\nExamples\n\nusing OpenEng.Viz\n\n# Plot a signal\nt = 0:0.01:10\ny = sin.(t)\nplot_signal(t, y, title=\"Sine Wave\")\n\n# Plot spectrum\nX = fft(y)\nfreqs = fftfreq(length(y), 100)\nplot_spectrum(freqs, abs.(X))\n\n\n\n\n\n","category":"module"},{"location":"api/#OpenEng.Viz.plot_heatmap-Tuple{Any}","page":"API Reference","title":"OpenEng.Viz.plot_heatmap","text":"plot_heatmap(z; kwargs...) -> plot\n\nPlot a 2D heatmap.\n\nArguments\n\nz: Matrix of values\nkwargs...: Additional plotting options\n\nReturns\n\nPlots.jl plot object\n\nExamples\n\nz = rand(20, 20)\nplot_heatmap(z, title=\"Heatmap\")\n\n\n\n\n\n","category":"method"},{"location":"api/#OpenEng.Viz.plot_response-Tuple{Any, Any}","page":"API Reference","title":"OpenEng.Viz.plot_response","text":"plot_response(t, y; response_type=\"Step\", kwargs...) -> plot\n\nPlot system response (step, impulse, etc.).\n\nArguments\n\nt: Time vector\ny: Response values\nresponse_type: Type of response (\"Step\", \"Impulse\", etc.)\nkwargs...: Additional plotting options\n\nReturns\n\nPlots.jl plot object\n\nExamples\n\nusing OpenEng.Simulation\nsys = tf([1.0], [1.0, 2.0, 1.0])\nt, y = step_response(sys, 5.0)\nplot_response(t, y, response_type=\"Step\")\n\n\n\n\n\n","category":"method"},{"location":"api/#OpenEng.Viz.plot_signal-Tuple{Any, Any}","page":"API Reference","title":"OpenEng.Viz.plot_signal","text":"plot_signal(t, y; kwargs...) -> plot\n\nPlot a time-domain signal.\n\nArguments\n\nt: Time vector\ny: Signal values\nkwargs...: Additional plotting options (title, xlabel, ylabel, etc.)\n\nReturns\n\nPlots.jl plot object\n\nExamples\n\nt = 0:0.01:10\ny = sin.(2π * t)\nplot_signal(t, y, title=\"Sine Wave\", xlabel=\"Time (s)\", ylabel=\"Amplitude\")\n\n\n\n\n\n","category":"method"},{"location":"api/#OpenEng.Viz.plot_signals-Tuple{Any, Any}","page":"API Reference","title":"OpenEng.Viz.plot_signals","text":"plot_signals(t, Y; labels=nothing, kwargs...) -> plot\n\nPlot multiple signals on the same axes.\n\nArguments\n\nt: Time vector\nY: Matrix where each column is a signal, or vector of signal vectors\nlabels: Signal labels\nkwargs...: Additional plotting options\n\nReturns\n\nPlots.jl plot object\n\nExamples\n\nt = 0:0.01:10\ny1 = sin.(t)\ny2 = cos.(t)\nplot_signals(t, [y1 y2], labels=[\"sin\" \"cos\"])\n\n\n\n\n\n","category":"method"},{"location":"api/#OpenEng.Viz.plot_spectrogram-Tuple{Any, Any, Any}","page":"API Reference","title":"OpenEng.Viz.plot_spectrogram","text":"plot_spectrogram(S, freqs, times; kwargs...) -> plot\n\nPlot a spectrogram.\n\nArguments\n\nS: Spectrogram matrix (frequency × time)\nfreqs: Frequency vector\ntimes: Time vector\nkwargs...: Additional plotting options\n\nReturns\n\nPlots.jl plot object\n\nExamples\n\nusing OpenEng.Signal\nx = randn(10000)\nS, f, t = compute_spectrogram(x)\nplot_spectrogram(S, f, t)\n\n\n\n\n\n","category":"method"},{"location":"api/#OpenEng.Viz.plot_spectrum-Tuple{Any, Any}","page":"API Reference","title":"OpenEng.Viz.plot_spectrum","text":"plot_spectrum(freqs, magnitude; kwargs...) -> plot\n\nPlot frequency spectrum (magnitude).\n\nArguments\n\nfreqs: Frequency vector\nmagnitude: Magnitude values\nkwargs...: Additional plotting options\n\nReturns\n\nPlots.jl plot object\n\nExamples\n\nusing FFTW\nx = sin.(2π * 5 .* (0:0.001:1))\nX = fft(x)\nfreqs = fftfreq(length(x), 1000)\nplot_spectrum(freqs[1:length(freqs)÷2], abs.(X[1:length(X)÷2]))\n\n\n\n\n\n","category":"method"},{"location":"api/#OpenEng.Viz.plot_surface-Tuple{Any, Any, Any}","page":"API Reference","title":"OpenEng.Viz.plot_surface","text":"plot_surface(x, y, z; kwargs...) -> plot\n\nPlot a 3D surface.\n\nArguments\n\nx: X coordinates (vector or matrix)\ny: Y coordinates (vector or matrix)\nz: Z values (matrix)\nkwargs...: Additional plotting options\n\nReturns\n\nPlots.jl plot object\n\nExamples\n\nx = -3:0.1:3\ny = -3:0.1:3\nz = [sin(sqrt(xi^2 + yi^2)) for xi in x, yi in y]\nplot_surface(x, y, z, title=\"3D Surface\")\n\n\n\n\n\n","category":"method"},{"location":"api/#OpenEng.Viz.save_plot-Tuple{Any, String}","page":"API Reference","title":"OpenEng.Viz.save_plot","text":"save_plot(p, filename; kwargs...)\n\nSave a plot to file.\n\nArguments\n\np: Plot object\nfilename: Output filename\nkwargs...: Additional save options (size, dpi, etc.)\n\nExamples\n\np = plot_signal(t, y)\nsave_plot(p, \"signal.png\", size=(800, 600), dpi=300)\n\n\n\n\n\n","category":"method"},{"location":"api/#OpenEng.Viz.set_default_backend","page":"API Reference","title":"OpenEng.Viz.set_default_backend","text":"set_default_backend(backend=:gr)\n\nSet the default plotting backend.\n\nArguments\n\nbackend: Backend to use (:gr, :pyplot, :plotly)\n\nExamples\n\nset_default_backend(:gr)\n\n\n\n\n\n","category":"function"},{"location":"api/#GPU-Computing","page":"API Reference","title":"GPU Computing","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Modules = [OpenEng.GPU]","category":"page"},{"location":"api/#OpenEng.GPU","page":"API Reference","title":"OpenEng.GPU","text":"OpenEng.GPU\n\nGPU-accelerated computing with automatic CPU fallback.\n\nThis module provides GPU acceleration using CUDA.jl for NVIDIA GPUs, with automatic fallback to multi-threaded CPU operations when GPU is unavailable.\n\nMain Functions\n\ngpu_available: Check if GPU is available\nto_gpu: Transfer data to GPU\nto_cpu: Transfer data back to CPU\ngpu_matmul: GPU matrix multiplication\ngpu_fft: GPU FFT\n\nExamples\n\nusing OpenEng.GPU\n\nif gpu_available()\n    A_gpu = to_gpu(A)\n    B_gpu = to_gpu(B)\n    C_gpu = gpu_matmul(A_gpu, B_gpu)\n    C = to_cpu(C_gpu)\nelse\n    C = A * B  # CPU fallback\nend\n\n\n\n\n\n","category":"module"},{"location":"api/#OpenEng.GPU.device_array-Tuple{AbstractArray}","page":"API Reference","title":"OpenEng.GPU.device_array","text":"device_array(A) -> A_device\n\nEnsure array is on the appropriate device (GPU if available, CPU otherwise).\n\nArguments\n\nA: Input array\n\nReturns\n\nArray on the appropriate device\n\nExamples\n\nA = device_array(rand(100, 100))\n\n\n\n\n\n","category":"method"},{"location":"api/#OpenEng.GPU.gpu_add-Tuple{AbstractArray, AbstractArray}","page":"API Reference","title":"OpenEng.GPU.gpu_add","text":"gpu_add(A, B) -> C\n\nElement-wise addition on GPU if available.\n\nArguments\n\nA: First array\nB: Second array\n\nReturns\n\nElement-wise sum\n\nExamples\n\nC = gpu_add(A, B)\n\n\n\n\n\n","category":"method"},{"location":"api/#OpenEng.GPU.gpu_available-Tuple{}","page":"API Reference","title":"OpenEng.GPU.gpu_available","text":"gpu_available() -> Bool\n\nCheck if GPU acceleration is available.\n\nReturns\n\ntrue if a functional GPU is available, false otherwise\n\nExamples\n\nif gpu_available()\n    println(\"GPU acceleration enabled\")\nelse\n    println(\"Using CPU\")\nend\n\n\n\n\n\n","category":"method"},{"location":"api/#OpenEng.GPU.gpu_enabled-Tuple{}","page":"API Reference","title":"OpenEng.GPU.gpu_enabled","text":"gpu_enabled() -> Bool\n\nCheck if GPU operations are enabled (alias for gpu_available).\n\n\n\n\n\n","category":"method"},{"location":"api/#OpenEng.GPU.gpu_matmul-Tuple{AbstractMatrix, AbstractMatrix}","page":"API Reference","title":"OpenEng.GPU.gpu_matmul","text":"gpu_matmul(A, B) -> C\n\nPerform matrix multiplication on GPU if available, otherwise CPU.\n\nArguments\n\nA: First matrix\nB: Second matrix\n\nReturns\n\nProduct C = A * B\n\nExamples\n\nA = rand(1000, 1000)\nB = rand(1000, 1000)\nC = gpu_matmul(A, B)\n\n\n\n\n\n","category":"method"},{"location":"api/#OpenEng.GPU.gpu_multiply-Tuple{AbstractArray, AbstractArray}","page":"API Reference","title":"OpenEng.GPU.gpu_multiply","text":"gpu_multiply(A, B) -> C\n\nElement-wise multiplication on GPU if available.\n\nArguments\n\nA: First array\nB: Second array\n\nReturns\n\nElement-wise product\n\nExamples\n\nA = rand(1000, 1000)\nB = rand(1000, 1000)\nC = gpu_multiply(A, B)\n\n\n\n\n\n","category":"method"},{"location":"api/#OpenEng.GPU.gpu_subtract-Tuple{AbstractArray, AbstractArray}","page":"API Reference","title":"OpenEng.GPU.gpu_subtract","text":"gpu_subtract(A, B) -> C\n\nElement-wise subtraction on GPU if available.\n\nArguments\n\nA: First array\nB: Second array\n\nReturns\n\nElement-wise difference\n\nExamples\n\nC = gpu_subtract(A, B)\n\n\n\n\n\n","category":"method"},{"location":"api/#OpenEng.GPU.gpu_transpose-Tuple{AbstractMatrix}","page":"API Reference","title":"OpenEng.GPU.gpu_transpose","text":"gpu_transpose(A) -> A'\n\nTranspose matrix on GPU if available.\n\nArguments\n\nA: Input matrix\n\nReturns\n\nTransposed matrix\n\nExamples\n\nAt = gpu_transpose(A)\n\n\n\n\n\n","category":"method"},{"location":"api/#OpenEng.GPU.has_cuda-Tuple{}","page":"API Reference","title":"OpenEng.GPU.has_cuda","text":"has_cuda() -> Bool\n\nCheck if CUDA is available (alias for gpu_available).\n\n\n\n\n\n","category":"method"},{"location":"api/#OpenEng.GPU.to_cpu-Tuple{AbstractArray}","page":"API Reference","title":"OpenEng.GPU.to_cpu","text":"to_cpu(A) -> A_cpu\n\nTransfer array from GPU to CPU memory.\n\nIf input is already a CPU array, returns it unchanged.\n\nArguments\n\nA: GPU or CPU array\n\nReturns\n\nCPU array\n\nExamples\n\nA_cpu = to_cpu(A_gpu)\n\n\n\n\n\n","category":"method"},{"location":"api/#OpenEng.GPU.to_gpu-Tuple{AbstractArray}","page":"API Reference","title":"OpenEng.GPU.to_gpu","text":"to_gpu(A) -> A_gpu\n\nTransfer array to GPU memory.\n\nIf GPU is not available, returns the input array unchanged.\n\nArguments\n\nA: CPU array\n\nReturns\n\nGPU array if available, otherwise CPU array\n\nExamples\n\nA = rand(1000, 1000)\nA_gpu = to_gpu(A)\n\n\n\n\n\n","category":"method"},{"location":"api/#OpenEng.GPU.@maybe_gpu-Tuple{Any}","page":"API Reference","title":"OpenEng.GPU.@maybe_gpu","text":"@maybe_gpu expr\n\nMacro to conditionally execute code on GPU if available.\n\nExamples\n\n@maybe_gpu begin\n    A_gpu = CuArray(A)\n    B_gpu = A_gpu * A_gpu\nend\n\n\n\n\n\n","category":"macro"},{"location":"api/#Utilities","page":"API Reference","title":"Utilities","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Modules = [OpenEng.Utils]","category":"page"},{"location":"api/#OpenEng.Utils","page":"API Reference","title":"OpenEng.Utils","text":"OpenEng.Utils\n\nUtility functions, I/O operations, and unit conversions.\n\nThis module provides auxiliary tools for file I/O, unit conversions, physical constants, and performance monitoring.\n\nMain Functions\n\nread_csv, write_csv: CSV file I/O\nread_mat, write_mat: MATLAB file I/O\nread_hdf5, write_hdf5: HDF5 file I/O\nconvert_units: Unit conversion\nPhysical constants: SPEED_OF_LIGHT, GRAVITY, etc.\n\nExamples\n\nusing OpenEng.Utils\n\n# File I/O\ndata = read_csv(\"data.csv\")\nwrite_mat(\"output.mat\", Dict(\"data\" => data))\n\n# Unit conversion\nmeters = convert_units(5.0, :km, :m)  # 5000.0\n\n# Constants\nc = SPEED_OF_LIGHT  # m/s\n\n\n\n\n\n","category":"module"},{"location":"api/#OpenEng.Utils.Timer","page":"API Reference","title":"OpenEng.Utils.Timer","text":"timer() -> Timer\n\nCreate a simple timer for performance measurement.\n\nReturns\n\nTimer object\n\nExamples\n\nt = timer()\n# ... do work ...\nelapsed = t.elapsed()\n\n\n\n\n\n","category":"type"},{"location":"api/#OpenEng.Utils.convert_units-Tuple{Real, Symbol, Symbol}","page":"API Reference","title":"OpenEng.Utils.convert_units","text":"convert_units(value, from_unit, to_unit) -> converted_value\n\nConvert between units using Unitful.jl.\n\nArguments\n\nvalue: Numeric value\nfrom_unit: Source unit (symbol)\nto_unit: Target unit (symbol)\n\nReturns\n\nConverted value (unitless)\n\nExamples\n\nkm_to_m = convert_units(5.0, :km, :m)  # 5000.0\ns_to_ms = convert_units(1.0, :s, :ms)  # 1000.0\n\n\n\n\n\n","category":"method"},{"location":"api/#OpenEng.Utils.parse_unit-Tuple{Symbol}","page":"API Reference","title":"OpenEng.Utils.parse_unit","text":"parse_unit(unit_symbol) -> Unitful.Unit\n\nParse a unit symbol into a Unitful unit.\n\nArguments\n\nunit_symbol: Unit as a symbol (e.g., :m, :km, :s)\n\nReturns\n\nUnitful.Unit object\n\nExamples\n\nm = parse_unit(:m)\nkm = parse_unit(:km)\n\n\n\n\n\n","category":"method"},{"location":"api/#OpenEng.Utils.read_csv-Tuple{String}","page":"API Reference","title":"OpenEng.Utils.read_csv","text":"read_csv(filename; kwargs...) -> DataFrame\n\nRead data from a CSV file.\n\nArguments\n\nfilename: Path to CSV file\nkwargs...: Additional arguments passed to CSV.File\n\nReturns\n\nDataFrame containing the data\n\nExamples\n\ndf = read_csv(\"data.csv\")\n\n\n\n\n\n","category":"method"},{"location":"api/#OpenEng.Utils.read_hdf5-Tuple{String, String}","page":"API Reference","title":"OpenEng.Utils.read_hdf5","text":"read_hdf5(filename, dataset) -> Array\n\nRead a dataset from an HDF5 file.\n\nArguments\n\nfilename: Path to HDF5 file\ndataset: Name of dataset to read\n\nReturns\n\nArray containing the dataset\n\nExamples\n\ndata = read_hdf5(\"data.h5\", \"dataset1\")\n\n\n\n\n\n","category":"method"},{"location":"api/#OpenEng.Utils.read_mat-Tuple{String}","page":"API Reference","title":"OpenEng.Utils.read_mat","text":"read_mat(filename) -> Dict\n\nRead data from a MATLAB .mat file.\n\nArguments\n\nfilename: Path to .mat file\n\nReturns\n\nDictionary with variable names as keys\n\nExamples\n\ndata = read_mat(\"data.mat\")\nA = data[\"A\"]\n\n\n\n\n\n","category":"method"},{"location":"api/#OpenEng.Utils.write_csv-Tuple{String, Any}","page":"API Reference","title":"OpenEng.Utils.write_csv","text":"write_csv(filename, data; kwargs...)\n\nWrite data to a CSV file.\n\nArguments\n\nfilename: Path to output CSV file\ndata: DataFrame or matrix to write\nkwargs...: Additional arguments passed to CSV.write\n\nExamples\n\ndf = DataFrame(x=1:10, y=rand(10))\nwrite_csv(\"output.csv\", df)\n\n\n\n\n\n","category":"method"},{"location":"api/#OpenEng.Utils.write_hdf5-Tuple{String, String, Any}","page":"API Reference","title":"OpenEng.Utils.write_hdf5","text":"write_hdf5(filename, dataset, data)\n\nWrite data to an HDF5 file.\n\nArguments\n\nfilename: Path to output HDF5 file\ndataset: Name of dataset\ndata: Data to write\n\nExamples\n\nwrite_hdf5(\"output.h5\", \"mydata\", rand(100, 100))\n\n\n\n\n\n","category":"method"},{"location":"api/#OpenEng.Utils.write_mat-Tuple{String, Dict}","page":"API Reference","title":"OpenEng.Utils.write_mat","text":"write_mat(filename, data::Dict)\n\nWrite data to a MATLAB .mat file.\n\nArguments\n\nfilename: Path to output .mat file\ndata: Dictionary with variable names and values\n\nExamples\n\ndata = Dict(\"A\" => rand(10, 10), \"b\" => rand(10))\nwrite_mat(\"output.mat\", data)\n\n\n\n\n\n","category":"method"},{"location":"api/#OpenEng.Utils.@timed_section-Tuple{Any, Any}","page":"API Reference","title":"OpenEng.Utils.@timed_section","text":"@timed_section name expr\n\nExecute a code block and report execution time.\n\nArguments\n\nname: Description of the timed section\nexpr: Code to execute\n\nExamples\n\n@timed_section \"Matrix multiplication\" begin\n    C = A * B\nend\n\n\n\n\n\n","category":"macro"},{"location":"simulation/#Simulation","page":"Simulation","title":"Simulation","text":"","category":"section"},{"location":"simulation/","page":"Simulation","title":"Simulation","text":"The OpenEng.Simulation module provides tools for simulating ordinary differential equations (ODEs), partial differential equations (PDEs), and control systems.","category":"page"},{"location":"simulation/#Overview","page":"Simulation","title":"Overview","text":"","category":"section"},{"location":"simulation/","page":"Simulation","title":"Simulation","text":"This module integrates DifferentialEquations.jl and ControlSystems.jl to provide comprehensive simulation capabilities.","category":"page"},{"location":"simulation/#ODE-Solvers","page":"Simulation","title":"ODE Solvers","text":"","category":"section"},{"location":"simulation/","page":"Simulation","title":"Simulation","text":"using OpenEng.Simulation\n\n# Define ODE: dy/dt = -0.5*y\nfunction exponential_decay!(du, u, p, t)\n    du[1] = -0.5 * u[1]\nend\n\nu0 = [1.0]\ntspan = (0.0, 10.0)\nsol = solve_ode(exponential_decay!, u0, tspan)","category":"page"},{"location":"simulation/#Control-Systems","page":"Simulation","title":"Control Systems","text":"","category":"section"},{"location":"simulation/#Transfer-Functions","page":"Simulation","title":"Transfer Functions","text":"","category":"section"},{"location":"simulation/","page":"Simulation","title":"Simulation","text":"# First-order system: H(s) = 1/(s+1)\nsys = tf([1.0], [1.0, 1.0])\n\n# Step response\nt, y = step_response(sys, 5.0)\n\n# Impulse response\nt, y = impulse_response(sys, 5.0)\n\n# Frequency response\nω = 10 .^ range(-2, 2, length=100)\nmag, phase = frequency_response(sys, ω)","category":"page"},{"location":"simulation/#State-Space-Systems","page":"Simulation","title":"State-Space Systems","text":"","category":"section"},{"location":"simulation/","page":"Simulation","title":"Simulation","text":"A = [-1.0 0.0; 0.0 -2.0]\nB = [1.0; 1.0]\nC = [1.0 1.0]\nD = [0.0]\n\nsys = create_ss(A, B, C, D)","category":"page"},{"location":"simulation/#Main-Functions","page":"Simulation","title":"Main Functions","text":"","category":"section"},{"location":"simulation/","page":"Simulation","title":"Simulation","text":"solve_ode - Solve ODE with default solver\nsolve_ode_adaptive - Adaptive ODE solver\nstep_response - System step response\nimpulse_response - System impulse response\nfrequency_response - Bode analysis\nsimulate_system - System simulation with input","category":"page"},{"location":"simulation/#Examples","page":"Simulation","title":"Examples","text":"","category":"section"},{"location":"simulation/","page":"Simulation","title":"Simulation","text":"See examples/simulation_examples.jl for comprehensive examples.","category":"page"},{"location":"linear_algebra/#Linear-Algebra","page":"Linear Algebra","title":"Linear Algebra","text":"","category":"section"},{"location":"linear_algebra/","page":"Linear Algebra","title":"Linear Algebra","text":"The OpenEng.LA module provides advanced linear algebra operations and matrix computations.","category":"page"},{"location":"linear_algebra/#Overview","page":"Linear Algebra","title":"Overview","text":"","category":"section"},{"location":"linear_algebra/","page":"Linear Algebra","title":"Linear Algebra","text":"This module offers convenient wrappers and extensions to Julia's LinearAlgebra and SparseArrays packages, with MATLAB-compatible naming where appropriate.","category":"page"},{"location":"linear_algebra/#Main-Functions","page":"Linear Algebra","title":"Main Functions","text":"","category":"section"},{"location":"linear_algebra/#Eigenvalues-and-Eigenvectors","page":"Linear Algebra","title":"Eigenvalues and Eigenvectors","text":"","category":"section"},{"location":"linear_algebra/","page":"Linear Algebra","title":"Linear Algebra","text":"using OpenEng.LA\n\nA = [3.0 2.0; 1.0 4.0]\nλ, V = eig(A)  # Eigenvalues and eigenvectors","category":"page"},{"location":"linear_algebra/#Matrix-Decompositions","page":"Linear Algebra","title":"Matrix Decompositions","text":"","category":"section"},{"location":"linear_algebra/","page":"Linear Algebra","title":"Linear Algebra","text":"svd(A) - Singular Value Decomposition\nqr(A) - QR decomposition\nlu(A) - LU decomposition  \nchol(A) - Cholesky decomposition","category":"page"},{"location":"linear_algebra/#Linear-Systems","page":"Linear Algebra","title":"Linear Systems","text":"","category":"section"},{"location":"linear_algebra/","page":"Linear Algebra","title":"Linear Algebra","text":"solve(A, b) - Solve linear system Ax = b\ninv(A) - Matrix inverse\npinv(A) - Pseudoinverse","category":"page"},{"location":"linear_algebra/#Matrix-Operations","page":"Linear Algebra","title":"Matrix Operations","text":"","category":"section"},{"location":"linear_algebra/","page":"Linear Algebra","title":"Linear Algebra","text":"matrix_power(A, n) - Compute A^n\nmatrix_exp(A) - Matrix exponential\nfrobenius_norm(A) - Frobenius norm\nspectral_norm(A) - Spectral (2-norm)","category":"page"},{"location":"linear_algebra/#Sparse-Matrices","page":"Linear Algebra","title":"Sparse Matrices","text":"","category":"section"},{"location":"linear_algebra/","page":"Linear Algebra","title":"Linear Algebra","text":"sparse(I, J, V) - Create sparse matrix\nissparse(A) - Check if sparse\nnnz(A) - Number of non-zeros","category":"page"},{"location":"linear_algebra/#Examples","page":"Linear Algebra","title":"Examples","text":"","category":"section"},{"location":"linear_algebra/","page":"Linear Algebra","title":"Linear Algebra","text":"See examples/linear_algebra_examples.jl for comprehensive examples.","category":"page"},{"location":"linear_algebra/#API-Reference","page":"Linear Algebra","title":"API Reference","text":"","category":"section"},{"location":"linear_algebra/#OpenEng.LA.eig","page":"Linear Algebra","title":"OpenEng.LA.eig","text":"eig(A) -> (λ, V)\n\nCompute eigenvalues and eigenvectors of matrix A.\n\nReturns a tuple (λ, V) where λ is a vector of eigenvalues and V is a matrix whose columns are the corresponding eigenvectors.\n\nArguments\n\nA: A square matrix\n\nReturns\n\nλ: Vector of eigenvalues\nV: Matrix of eigenvectors (columns)\n\nExamples\n\nA = [3.0 2.0; 1.0 4.0]\nλ, V = eig(A)\n\n\n\n\n\n","category":"function"},{"location":"linear_algebra/#OpenEng.LA.svd","page":"Linear Algebra","title":"OpenEng.LA.svd","text":"svd(A) -> (U, S, Vt)\n\nCompute the singular value decomposition of matrix A.\n\nReturns MATLAB-style tuple (U, S, Vt) where A ≈ U * Diagonal(S) * Vt.\n\nArguments\n\nA: Matrix to decompose\n\nReturns\n\nU: Left singular vectors (m × k matrix for thin SVD)\nS: Singular values (vector of length k)\nVt: Right singular vectors transposed (k × n matrix)\n\nExamples\n\nA = rand(5, 3)\nU, S, Vt = svd(A)\n@assert A ≈ U * Diagonal(S) * Vt\n\n\n\n\n\n","category":"function"},{"location":"linear_algebra/#OpenEng.LA.chol","page":"Linear Algebra","title":"OpenEng.LA.chol","text":"chol(A) -> U\n\nCompute the Cholesky decomposition of a positive definite matrix A.\n\nReturns the upper triangular matrix U such that A = U'U.\n\nArguments\n\nA: A positive definite matrix\n\nReturns\n\nU: Upper triangular Cholesky factor\n\nExamples\n\nA = [4.0 2.0; 2.0 3.0]\nU = chol(A)\n@assert A ≈ U'U\n\n\n\n\n\n","category":"function"},{"location":"linear_algebra/#OpenEng.LA.solve","page":"Linear Algebra","title":"OpenEng.LA.solve","text":"solve(A, b) -> x\n\nSolve the linear system Ax = b.\n\nArguments\n\nA: Coefficient matrix\nb: Right-hand side vector or matrix\n\nReturns\n\nx: Solution vector or matrix\n\nExamples\n\nA = [3.0 2.0; 1.0 4.0]\nb = [1.0, 2.0]\nx = solve(A, b)\n@assert A * x ≈ b\n\n\n\n\n\n","category":"function"},{"location":"linear_algebra/#OpenEng.LA.matrix_power","page":"Linear Algebra","title":"OpenEng.LA.matrix_power","text":"matrix_power(A, n) -> A^n\n\nCompute the n-th power of a matrix A.\n\nArguments\n\nA: A square matrix\nn: Integer exponent\n\nReturns\n\nA^n: Matrix power\n\nExamples\n\nA = [1.0 1.0; 0.0 1.0]\nA2 = matrix_power(A, 2)\n\n\n\n\n\n","category":"function"},{"location":"getting_started/#Getting-Started-with-OpenEng.jl","page":"Getting Started","title":"Getting Started with OpenEng.jl","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"This guide will help you get started with OpenEng.jl.","category":"page"},{"location":"getting_started/#Installation","page":"Getting Started","title":"Installation","text":"","category":"section"},{"location":"getting_started/#Requirements","page":"Getting Started","title":"Requirements","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Julia 1.10 or later\nRecommended: 4GB RAM for typical usage\nOptional: NVIDIA GPU for GPU acceleration","category":"page"},{"location":"getting_started/#Installing-Julia","page":"Getting Started","title":"Installing Julia","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Download Julia from julialang.org.","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"On Ubuntu/Debian:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"wget https://julialang-s3.julialang.org/bin/linux/x64/1.10/julia-1.10-latest-linux-x86_64.tar.gz\ntar -xvzf julia-1.10-latest-linux-x86_64.tar.gz\nsudo mv julia-1.10 /opt/\nsudo ln -s /opt/julia-1.10/bin/julia /usr/local/bin/julia","category":"page"},{"location":"getting_started/#Installing-OpenEng.jl","page":"Getting Started","title":"Installing OpenEng.jl","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"using Pkg\nPkg.add(url=\"https://github.com/TheusHen/OpenEng.jl\")","category":"page"},{"location":"getting_started/#Development-Installation","page":"Getting Started","title":"Development Installation","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"git clone https://github.com/TheusHen/OpenEng.jl.git\ncd OpenEng.jl\njulia --project=. -e 'using Pkg; Pkg.instantiate()'","category":"page"},{"location":"getting_started/#First-Steps","page":"Getting Started","title":"First Steps","text":"","category":"section"},{"location":"getting_started/#Loading-the-Package","page":"Getting Started","title":"Loading the Package","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"using OpenEng","category":"page"},{"location":"getting_started/#Package-Information","page":"Getting Started","title":"Package Information","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"OpenEng.info()","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"This displays available modules and GPU status.","category":"page"},{"location":"getting_started/#Your-First-Computation","page":"Getting Started","title":"Your First Computation","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"using OpenEng.LA\n\n# Create a matrix\nA = [3.0 2.0; 1.0 4.0]\n\n# Compute eigenvalues\nλ, V = eig(A)\n\nprintln(\"Eigenvalues: \", λ)","category":"page"},{"location":"getting_started/#Basic-Workflows","page":"Getting Started","title":"Basic Workflows","text":"","category":"section"},{"location":"getting_started/#Linear-Algebra","page":"Getting Started","title":"Linear Algebra","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"using OpenEng.LA\n\n# Matrix operations\nA = rand(5, 5)\nB = rand(5, 5)\nC = A * B\n\n# Solve linear system\nb = rand(5)\nx = solve(A, b)\n\n# Decompositions\nU, S, Vt = svd(A)","category":"page"},{"location":"getting_started/#Signal-Processing","page":"Getting Started","title":"Signal Processing","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"using OpenEng.Signal\n\n# Generate signal\nfs = 1000.0\nt = 0:1/fs:1-1/fs\nx = sin.(2π * 10 .* t)\n\n# Compute FFT\nX = fft(x)\nfreqs = fftfreq(length(x), 1/fs)\n\n# Filter design\nb, a = butter(4, 0.2)\ny = filter_signal(b, a, x)","category":"page"},{"location":"getting_started/#System-Simulation","page":"Getting Started","title":"System Simulation","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"using OpenEng.Simulation\n\n# Define ODE\nfunction exponential!(du, u, p, t)\n    du[1] = -0.5 * u[1]\nend\n\n# Solve\nu0 = [1.0]\ntspan = (0.0, 10.0)\nsol = solve_ode(exponential!, u0, tspan)","category":"page"},{"location":"getting_started/#Optimization","page":"Getting Started","title":"Optimization","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"using OpenEng.Optimization\n\n# Linear programming\nmodel = create_lp_model()\n@variable(model, x >= 0)\n@variable(model, y >= 0)\n@constraint(model, x + y <= 10)\n@objective(model, Max, 3x + 5y)\noptimize!(model)\n\nprintln(\"x = \", value(x))\nprintln(\"y = \", value(y))","category":"page"},{"location":"getting_started/#Visualization","page":"Getting Started","title":"Visualization","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"using OpenEng.Viz\n\nt = 0:0.01:10\ny = sin.(t)\nplot_signal(t, y, title=\"Sine Wave\")","category":"page"},{"location":"getting_started/#GPU-Computing","page":"Getting Started","title":"GPU Computing","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"OpenEng.jl automatically detects GPU availability:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"using OpenEng.GPU\n\nif gpu_available()\n    A = rand(1000, 1000)\n    B = rand(1000, 1000)\n    C = gpu_matmul(A, B)\nelse\n    println(\"GPU not available, using CPU\")\nend","category":"page"},{"location":"getting_started/#Next-Steps","page":"Getting Started","title":"Next Steps","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Explore the Examples\nRead module-specific documentation:\nLinear Algebra\nSimulation\nSignal Processing\nOptimization\nCheck the API Reference","category":"page"},{"location":"getting_started/#Getting-Help","page":"Getting Started","title":"Getting Help","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Documentation: You're reading it!\nExamples: See the examples/ directory\nIssues: GitHub Issues\nDiscussions: GitHub Discussions","category":"page"},{"location":"getting_started/#Common-Issues","page":"Getting Started","title":"Common Issues","text":"","category":"section"},{"location":"getting_started/#Package-Not-Found","page":"Getting Started","title":"Package Not Found","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"If you get a \"package not found\" error, make sure you're using the correct URL:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Pkg.add(url=\"https://github.com/TheusHen/OpenEng.jl\")","category":"page"},{"location":"getting_started/#CUDA-Not-Available","page":"Getting Started","title":"CUDA Not Available","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"GPU acceleration is optional. OpenEng.jl works fine without CUDA:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"# To add CUDA support (optional):\nusing Pkg\nPkg.add(\"CUDA\")","category":"page"},{"location":"getting_started/#Test-Failures","page":"Getting Started","title":"Test Failures","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"To run the test suite:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"julia --project=. -e 'using Pkg; Pkg.test()'","category":"page"},{"location":"examples/#Examples","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"OpenEng.jl includes comprehensive examples demonstrating all major features.","category":"page"},{"location":"examples/#Running-Examples","page":"Examples","title":"Running Examples","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"All examples are located in the examples/ directory and can be run directly:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"julia --project examples/linear_algebra_examples.jl\njulia --project examples/signal_processing_examples.jl\njulia --project examples/optimization_examples.jl\njulia --project examples/simulation_examples.jl","category":"page"},{"location":"examples/#Linear-Algebra-Examples","page":"Examples","title":"Linear Algebra Examples","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"The linear_algebra_examples.jl file demonstrates:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Eigenvalue Decomposition - Computing eigenvalues and eigenvectors\nSVD - Singular value decomposition and matrix reconstruction\nLinear Systems - Solving Ax = b\nMatrix Powers - Computing A^n efficiently\nSparse Matrices - Working with large sparse systems\nCholesky Decomposition - For positive definite matrices\nMatrix Norms - Frobenius and spectral norms","category":"page"},{"location":"examples/#Signal-Processing-Examples","page":"Examples","title":"Signal Processing Examples","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"The signal_processing_examples.jl file demonstrates:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"FFT Analysis - Frequency detection in signals\nMulti-tone Signals - Analyzing composite signals\nFiltering - Lowpass, highpass, bandpass filters\nFilter Design - Butterworth, Chebyshev, Elliptic filters\nPower Spectral Density - Using Welch's method\nSpectrograms - Time-frequency analysis\nConvolution and Correlation - Signal operations","category":"page"},{"location":"examples/#Optimization-Examples","page":"Examples","title":"Optimization Examples","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"The optimization_examples.jl file demonstrates:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Linear Programming - Production planning problems\nDiet Optimization - Meeting nutritional requirements\nTransportation - Minimizing shipping costs\nNonlinear Optimization - Rosenbrock function\nConstrained NLP - Circle constraint problems\nPortfolio Optimization - Asset allocation\nCurve Fitting - Parameter estimation\nInteger Programming - Resource allocation","category":"page"},{"location":"examples/#Simulation-Examples","page":"Examples","title":"Simulation Examples","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"The simulation_examples.jl file demonstrates:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"ODE Integration - Exponential decay\nHarmonic Oscillators - Undamped and damped systems\nControl Systems - Transfer functions\nStep Response - First and second-order systems\nImpulse Response - System characterization\nFrequency Response - Bode analysis\nState-Space Systems - Multi-variable systems","category":"page"},{"location":"examples/#Quick-Start-Example","page":"Examples","title":"Quick Start Example","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Here's a complete example combining multiple modules:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using OpenEng\n\n# 1. Generate a noisy signal\nfs = 1000.0  # Sampling rate\nt = 0:1/fs:1-1/fs\nsignal = sin.(2π * 50 .* t)  # 50 Hz sine\nnoisy = signal + 0.5 * randn(length(signal))\n\n# 2. Design and apply filter\nb, a = OpenEng.Signal.butter(4, 0.15)\nfiltered = OpenEng.Signal.filter_signal(b, a, noisy)\n\n# 3. Analyze spectrum\nX = OpenEng.Signal.fft(filtered)\nfreqs = OpenEng.Signal.fftfreq(length(filtered), 1/fs)\n\n# 4. Visualize results\nOpenEng.Viz.plot_signal(t, noisy, title=\"Noisy Signal\")\nOpenEng.Viz.plot_signal(t, filtered, title=\"Filtered Signal\")\nOpenEng.Viz.plot_spectrum(freqs[1:end÷2], abs.(X[1:end÷2]))\n\n# 5. Save results\ndata = Dict(\"time\" => t, \"signal\" => filtered)\nOpenEng.Utils.write_mat(\"output.mat\", data)","category":"page"},{"location":"examples/#Best-Practices","page":"Examples","title":"Best Practices","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Import specific modules when you only need certain functionality\nUse type-stable code for best performance\nProfile your code using the Timer utilities\nSave intermediate results using the I/O functions\nVisualize frequently to verify correctness","category":"page"},{"location":"examples/#Additional-Resources","page":"Examples","title":"Additional Resources","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"See the individual module documentation for detailed API references\nCheck the test files in test/ for additional usage examples\nRefer to the source code in src/ for implementation details","category":"page"},{"location":"gpu/#GPU-Computing","page":"GPU Computing","title":"GPU Computing","text":"","category":"section"},{"location":"gpu/","page":"GPU Computing","title":"GPU Computing","text":"The OpenEng.GPU module provides GPU acceleration with automatic CPU fallback.","category":"page"},{"location":"gpu/#Overview","page":"GPU Computing","title":"Overview","text":"","category":"section"},{"location":"gpu/","page":"GPU Computing","title":"GPU Computing","text":"This module uses CUDA.jl for NVIDIA GPU acceleration, automatically falling back to optimized CPU operations when GPU is unavailable.","category":"page"},{"location":"gpu/#GPU-Availability","page":"GPU Computing","title":"GPU Availability","text":"","category":"section"},{"location":"gpu/","page":"GPU Computing","title":"GPU Computing","text":"using OpenEng.GPU\n\nif gpu_available()\n    println(\"GPU acceleration enabled\")\nelse\n    println(\"Using CPU fallback\")\nend","category":"page"},{"location":"gpu/#Data-Transfer","page":"GPU Computing","title":"Data Transfer","text":"","category":"section"},{"location":"gpu/","page":"GPU Computing","title":"GPU Computing","text":"# Transfer to GPU\nA = rand(1000, 1000)\nA_gpu = to_gpu(A)\n\n# Transfer back to CPU\nA_cpu = to_cpu(A_gpu)","category":"page"},{"location":"gpu/#GPU-Operations","page":"GPU Computing","title":"GPU Operations","text":"","category":"section"},{"location":"gpu/#Matrix-Multiplication","page":"GPU Computing","title":"Matrix Multiplication","text":"","category":"section"},{"location":"gpu/","page":"GPU Computing","title":"GPU Computing","text":"A = rand(1000, 1000)\nB = rand(1000, 1000)\n\n# Automatically uses GPU if available\nC = gpu_matmul(A, B)","category":"page"},{"location":"gpu/#Element-wise-Operations","page":"GPU Computing","title":"Element-wise Operations","text":"","category":"section"},{"location":"gpu/","page":"GPU Computing","title":"GPU Computing","text":"# Element-wise multiplication\nC = gpu_multiply(A, B)\n\n# Element-wise addition\nC = gpu_add(A, B)\n\n# Element-wise subtraction\nC = gpu_subtract(A, B)","category":"page"},{"location":"gpu/#Matrix-Operations","page":"GPU Computing","title":"Matrix Operations","text":"","category":"section"},{"location":"gpu/","page":"GPU Computing","title":"GPU Computing","text":"# Transpose\nAt = gpu_transpose(A)","category":"page"},{"location":"gpu/#Device-Arrays","page":"GPU Computing","title":"Device Arrays","text":"","category":"section"},{"location":"gpu/","page":"GPU Computing","title":"GPU Computing","text":"# Ensure array is on appropriate device\nA = device_array(rand(100, 100))","category":"page"},{"location":"gpu/#Conditional-GPU-Code","page":"GPU Computing","title":"Conditional GPU Code","text":"","category":"section"},{"location":"gpu/","page":"GPU Computing","title":"GPU Computing","text":"@maybe_gpu begin\n    # This code runs only if GPU is available\n    A_gpu = CuArray(A)\n    B_gpu = A_gpu * A_gpu\nend","category":"page"},{"location":"gpu/#Main-Functions","page":"GPU Computing","title":"Main Functions","text":"","category":"section"},{"location":"gpu/","page":"GPU Computing","title":"GPU Computing","text":"gpu_available, has_cuda, gpu_enabled - Check GPU availability\nto_gpu - Transfer to GPU memory\nto_cpu - Transfer to CPU memory\ndevice_array - Ensure on appropriate device\ngpu_matmul - GPU matrix multiplication\ngpu_multiply - Element-wise multiplication\ngpu_add - Element-wise addition\ngpu_subtract - Element-wise subtraction\ngpu_transpose - Matrix transpose\n@maybe_gpu - Conditional GPU execution","category":"page"},{"location":"gpu/#Performance-Notes","page":"GPU Computing","title":"Performance Notes","text":"","category":"section"},{"location":"gpu/","page":"GPU Computing","title":"GPU Computing","text":"When GPU is not available:","category":"page"},{"location":"gpu/","page":"GPU Computing","title":"GPU Computing","text":"All operations automatically fall back to optimized CPU code\nUses multi-threaded BLAS for matrix operations\nNo code changes required for portability","category":"page"},{"location":"gpu/","page":"GPU Computing","title":"GPU Computing","text":"To enable GPU support:","category":"page"},{"location":"gpu/","page":"GPU Computing","title":"GPU Computing","text":"using Pkg\nPkg.add(\"CUDA\")","category":"page"},{"location":"#OpenEng.jl-Documentation","page":"Home","title":"OpenEng.jl Documentation","text":"","category":"section"},{"location":"#OpenEng.jl","page":"Home","title":"OpenEng.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"OpenEng.jl is an open-source scientific and engineering toolbox built in Julia, designed to provide a modern, free, high-performance alternative to MATLAB and its proprietary toolboxes.","category":"page"},{"location":"#Features","page":"Home","title":"Features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"High Performance: Julia's JIT compilation provides C/C++ level performance\nModern Design: Clean, modular API with intuitive function names\nGPU Acceleration: Optional CUDA support with automatic CPU fallback\nComprehensive: Covers linear algebra, simulation, signal processing, optimization, and more\nOpen Source: MIT licensed, free for all uses","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"using Pkg\nPkg.add(url=\"https://github.com/TheusHen/OpenEng.jl\")","category":"page"},{"location":"#Quick-Example","page":"Home","title":"Quick Example","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"using OpenEng\n\n# Linear algebra\nA = [3.0 2.0; 1.0 4.0]\nλ, V = OpenEng.LA.eig(A)\n\n# Signal processing\nx = sin.(2π * 5 .* (0:0.001:1))\nX = OpenEng.Signal.fft(x)\n\n# System simulation\nusing OpenEng.Simulation\nsys = tf([1.0], [1.0, 2.0, 1.0])\nt, y = step_response(sys, 5.0)","category":"page"},{"location":"#Modules","page":"Home","title":"Modules","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"OpenEng.jl is organized into specialized modules:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Linear Algebra: Advanced linear algebra operations\nSimulation: ODE/PDE solvers and control systems\nSignal Processing: Signal and image processing\nOptimization: Linear and nonlinear optimization\nVisualization: Visualization and plotting\nGPU Computing: GPU-accelerated computing\nUtilities: Utilities and I/O operations","category":"page"},{"location":"#Getting-Help","page":"Home","title":"Getting Help","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"GitHub Issues\nGitHub Discussions","category":"page"},{"location":"#Contributing","page":"Home","title":"Contributing","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Contributions are welcome! Please see the Contributing Guide.","category":"page"},{"location":"#License","page":"Home","title":"License","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"OpenEng.jl is released under the MIT License. See LICENSE for details.","category":"page"}]
}
